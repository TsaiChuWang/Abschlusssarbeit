
#define PARSER

#define PROGRAM_NAME            "./Parser.py"
#define TEMPERATUR_DATEI_WEG    "../Datei/Parser_Temperatur.txt"

#ifdef PARSER

/**
 * @brief Extracts and returns the numerical value after a colon (':') in the given string.
 *
 * This function searches for a colon (':') within the provided string `vorbereitete_schnur`.
 * Once the colon is found, it extracts the substring following it and converts it into a 
 * double. If no colon is found, the function returns `FEHLGESCHLAGEN`.
 *
 * @param vorbereitete_schnur The input string that contains a colon followed by a number.
 * @return The numerical value as a double extracted from the string. If no colon is found,
 *         returns `FEHLGESCHLAGEN`.
 */
double erhaltenWert(char* vorbereitete_schnur){
    int start_index = FEHLGESCHLAGEN;
    for(int index=0;index<strlen(vorbereitete_schnur);index++)
        if(*(vorbereitete_schnur+index)==':'){
            start_index = index+1;
            break;
        }
	if(start_index == FEHLGESCHLAGEN)	// Fehlererkennung
		return (double)FEHLGESCHLAGEN;

    char* substring = (char*)malloc(sizeof(char)*(strlen(vorbereitete_schnur)));
    memset(substring, '\0', strlen(substring));

    for(int index=0;index+start_index<strlen(vorbereitete_schnur);index++)
        *(substring+index) = *(vorbereitete_schnur+index+start_index);

#ifdef DRUCKEN_ERHALTENWERT_WERT_SCHNUR
	printf("%s\n", substring);
#endif

	// Erhalten Sie wert
	double wert = strtod(substring, NULL);
#ifdef DRUCKEN_ERHALTENWERT_WERT
	printf("wert = %lf\n", wert);
#endif
	free(substring);

	return wert;
}

/**
 * @brief Computes the value of alpha based on the result from an external Python script.
 * 
 * This function executes a Python script that processes a data file related to the input 
 * structure `streit` which extract the alpha value form the specified solution file a from the output. The script is executed 
 * using a system call, and the result is read from a temporary file.
 * 
 * @param streit The input structure containing information about the problem, streit.DATEI_NAME is the parameter of the file name used by the Python script.
 * 
 * @return The computed value of \a alpha. If the process fails, a default value 
 * `FEHLGESCHLAGEN` is returned.
 * 
 * @note If the file cannot be opened, the function will terminate the program with an error message.
 */

double erhaltenALPHA(struct Streit streit){
    double alpha = FEHLGESCHLAGEN;
    
    char * linie = NULL;
    size_t länge = 0;
    ssize_t read;

    char befehl[MAX_BEFEHL_LÄNGE];
    sprintf(befehl, "python3 "PROGRAM_NAME" 1 %s\n", streit.DATEI_NAME);
    system(befehl);

    FILE *dateizeiger = fopen(TEMPERATUR_DATEI_WEG, "r"); 
    if (dateizeiger == NULL) {
        printf("Fehler: Die Datei konnte nicht geöffnet werden.\n"); 
        exit(EXIT_FAILURE);
    }
 
    double nu = 0;
    while ((read = getline(&linie, &länge, dateizeiger)) != FEHLGESCHLAGEN)
        alpha = strtod(linie, NULL);

    fclose(dateizeiger);
    
#ifdef DRUCKEN_ERHALTET_ALPHA
    printf("alpha = "DRUCKEN_DOUBLE"\n", alpha);
#endif

    return alpha;
}

/**
 * @brief Reads and processes data from a file to populate a 3D array of double values.
 *
 * This function initializes a 3D array of size `[ANZAHL_KANTEN][ANZAHL_KNOTEN][ANZAHL_KNOTEN]` 
 * and populates it with values extracted from a file generated by a Python script. 
 * The file is read line by line to extract indices and values, which are then stored in the array.
 * 
 * @param streit A struct containing the necessary parameters for processing. It includes:
 *                - ANZAHL_KANTEN: The number of edges.
 *                - ANZAHL_KNOTEN: The number of nodes.
 *                - DATEI_NAME: The name of the file to be processed.
 * 
 * @return A pointer to a 3D array of double values, which contains the processed data.
 *         The array should be freed by the caller when no longer needed.
 *
 * @note The function executes a Python script using `system()` to generate the required file. 
 *       The generated file is then read line by line. If the file cannot be opened, the function
 *       will print an error message and exit.
 *
 * @warning Ensure that the `TEMPERATUR_DATEI_WEG` file path is correct and the file format 
 *          matches the expected format for parsing.
 */
double*** erhaltenPSDBurch(struct Streit streit){
    int ANZAHL_KANTEN = streit.ANZAHL_KANTEN;
	int ANZAHL_KNOTEN = streit.ANZAHL_KNOTEN;

    // Bruchsarray initialisieren
	double*** bruchsarray = (double***)calloc(ANZAHL_KANTEN, sizeof(double**));
	for(int kant = 0;kant<ANZAHL_KANTEN;kant++){
		*(bruchsarray+kant) = (double**)calloc(ANZAHL_KNOTEN, sizeof(double*));
		for(int knote_i= 0 ;knote_i<ANZAHL_KNOTEN;knote_i++)
			*(*(bruchsarray+kant)+knote_i) = (double*)calloc(ANZAHL_KNOTEN, sizeof(double));
	}

    char befehl[MAX_BEFEHL_LÄNGE];
    sprintf(befehl, "python3 "PROGRAM_NAME" 2 %s\n", streit.DATEI_NAME);
    system(befehl);

    // Lösungsdatei lesen
    FILE *dateizeiger = fopen(TEMPERATUR_DATEI_WEG, "r"); 
    if (dateizeiger == NULL) { 
        printf("Fehler: Die Datei konnte nicht geöffnet werden.\n"); 
        exit(EXIT_FAILURE);
    } 
    char * linie = NULL;
    size_t länge = 0;
    ssize_t read;

    int aktuell_kant_index = 0;
    int aktuell_quelle_index = 0;
    int aktuell_ziele_index = 1;

    while ((read = getline(&linie, &länge, dateizeiger)) != FEHLGESCHLAGEN) {
        char aktuell_quelle_index_puffer[3];
        memset(aktuell_quelle_index_puffer, '\0', 3);
        memcpy(aktuell_quelle_index_puffer, &linie[2],2);    
        aktuell_quelle_index = atoi(aktuell_quelle_index_puffer)-1;

        char aktuell_ziele_index_puffer[3];
        memset(aktuell_ziele_index_puffer, '\0', 3);
        memcpy(aktuell_ziele_index_puffer, &linie[5],2);   
        aktuell_ziele_index = atoi(aktuell_ziele_index_puffer)-1;

        char aktuell_kant_index_puffer[3];
        memset(aktuell_kant_index_puffer, '\0', 3);
        memcpy(aktuell_kant_index_puffer, &linie[9],2)-1;   
        aktuell_kant_index = atoi(aktuell_kant_index_puffer)-1;

        double wert = erhaltenWert(linie);

#ifdef DRUCKEN_ERHALTENPSDBRUCH_WERT
            printf("f_%02d_%02d(e%02d) = "DRUCKEN_DOUBLE"\n", aktuell_quelle_index+1, aktuell_ziele_index+1, aktuell_kant_index+1, wert);
#endif         
        bruchsarray[aktuell_kant_index][aktuell_quelle_index][aktuell_ziele_index] = wert;
    }

    fclose(dateizeiger);
    if (linie)
        free(linie);

    return bruchsarray;
}

#endif